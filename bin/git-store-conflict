#!/bin/bash
LF='
'

die () {
    echo >&2 "$*"
    exit 1
}

usage() {
cat <<EOF
usage: git store-conflict 

    -c     commit the merge in a ref named with the signature of the conflict in refs/conflicts/.
EOF
}

gitDir=$(git rev-parse --git-dir)
conflictName="${gitDir}/CONFLICT_NAME"
mergeHead="${gitDir}/MERGE_HEAD"

commit=false

while getopts "hc" opt; do
	case "$opt" in
	h)
		usage
		exit 0
	;;
	c)
		commit=true
	;;
	*)
		usage
		exit 1
	;;
	esac
done

if $commit && [ ! -f $conflictName ] ; then
	echo "There is no resolution ongoing." >&2
	exit 1
fi

if ! $commit && [ -f $conflictName ] ; then
	echo "You are in the middle of a resolution"
	exit 1
fi

if ! $commit ; then

	if [[ -n $(git diff-index HEAD) ]]
	then
	    die "The repository has to be clean"
	fi

	shift $(expr $OPTIND - 1)

	if [[ -n "$@" ]] ; then
	    remote=$@
	    git show-ref -q "$remote" || die "Ref not found : $remote"
	    echo $(git rev-parse $remote) > $mergeHead

	    common=$(git merge-base --all $remote HEAD)

	    git read-tree -u -m --aggressive $common HEAD $remote
	    
	    git-merge-index -o git-merge-one-file -a 2> /dev/null

	    if test $? -eq 0 ; then
			git reset -q --hard
			echo "No conflict with $remote"
			exit 0
		fi

	    git hash-conflict > $conflictName
	else
		usage
		exit 1
	fi
	
else 
	if [ -z "$(git ls-files --unmerged)" ] ; then
		# if all conflicts are resolved ...
		tree=$(git write-tree)
		commit=$(git commit-tree $tree -m "dudu" -p HEAD -p $(cat $mergeHead))
		conflictName="refs/conflicts/$(cat $conflictName)"
		git update-ref "$conflictName" "$commit" "" &> /dev/null || 
			die "Resolution $conflictName already exists. "\
			"If you want to override it, delete it first :${LF}git update-ref -d $conflictName"
		echo "$commit -> $conflictName" 
		rm $mergeHead $conflictName &> /dev/null
		git reset -q --hard
	else
		echo "All conflicts must be resolved"
		exit 1
	fi
fi
